​       虽然在类中基本组成就是成员属性和方法，但是在任何的语言里面结构也是允许嵌套的，所以在一个类的内部可以定义其他的类，这样的类就是内部类。

# 一、内部类基本概念

​        如果说内部类肯定其本身是一个独立且完善的类结构，在一个类的内部除了属性和方法之外可以继续使用class定义内部类。

```
class Outer {//外部类
    private String msg = "www.mldn.cn";//私有成员属性
    public void fun() {//普通方法
        Inner in = new Inner();
        in.print();
    }

    class Inner {//在Outer类的内部定义了Inner类
        public void print() {
            System.out.println(Outer.this.msg);//Outer类中的属性
        }
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Outer out = new Outer();
        out.fun();
    }
}
```

​        从代码上说其实内部类的代码并不复杂，和普通类一样清晰明了。

​        代码结构上说，内部类其实并不合理，内部类的缺陷在于破坏了程序的结构。但是内部类的好处需要将两个类分开就能看出来了

```
class Outer {//外部类
    private String msg = "www.mldn.cn";//私有成员属性
    public void fun() {//普通方法
        //思考五：需要将当前对象Outer传递到Inner类中
        Inner in = new Inner(this);
        in.print();
    }
    //思考一：msg的属性要是需要外部访问则需要getter()方法
    public String getMsg() {
        return this.msg;
    }
}

class Inner {//在Outer类的内部定义了Inner类
    //思考三：Inner这个类对象实例化时需要Outer类的引用
    private Outer out;
    //思考四：应该通过Inner类的构造方法获取Outer类对象
    public Inner(Outer out) {
        this.out = out;
    }

    public void print() {
        //思考二：如果想调用外部类的getter方法，一定需要有类对象
        System.out.println(this.out.getMsg());//Outer类中的属性
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Outer out = new Outer();
        out.fun();
    }
}
```

​        主要目的为了让Inner这个类访问Outer这个类的私有属性。因此内部类的绝对优势就是省去了一大堆的方法。

# 二、内部类相关说明

​        现在已经清楚地认识到了内部类的优势以及结构，那么随后需要对内部类进行一些相关的说明，现在所定义的内部类都属于普通的内部类的形式，普通的类内部往往会提供有属性和方法，需要注意的是，内部类虽然可以方便地访问外部类的中的私有成员和私有方法，同理，外部类也可以轻松访问内部类中的私有成员或私有方法

```
class Outer {//外部类
    private String msg = "www.mldn.cn";//私有成员属性
    public void fun() {//普通方法
        Inner in = new Inner();
        in.print();
        System.out.println(in.info);//访问内部类的私有属性
    }

    class Inner {//在Outer类的内部定义了Inner类
        private String info = "今天天气不好，收衣服啦！";
        public void print() {
            System.out.println(Outer.this.msg);//Outer类中的属性
        }
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Outer out = new Outer();
        out.fun();
    }
}
```

​        使用内部类之后，内部类和外部类之间的私有操作的访问就不再需要通过setter、getter以及其他的间接方式完成了，可以直接进行处理。

​        但是需要注意的是，内部类本身也属于一个类，虽然大部分的情况下内部类往往是被外部类包裹的，但是外部依然可以产生内部类的实例化对象，而此时内部类实例化对象的格式如下：

> 外部类.内部类 内部类对象 = new 外部类.new 内部类();

​       在内部类编译完成后会出现一个Outer$Inner.class类文件，其中“$”到程序中就会变成“.”。因此内部类的全称就是“外部类.内部类”。内部类与外部类之间可以直接进行私有成员的访问，这样一来内部类如果要是提供有实例化对象，一定要保证外部类已经有实例化对象了。

```
class Outer {//外部类
    private String msg = "www.mldn.cn";//私有成员属性

    class Inner {//在Outer类的内部定义了Inner类
        public void print() {
            System.out.println(Outer.this.msg);//Outer类中的属性
        }
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Outer.Inner in = new Outer().new Inner();
        in.print();
    }
}
```

​        如果此时Inner类只允许Outer类来使用，那么在这样的情况下就可以使用private私有定义。如果给Inner加上private，则Inner类无法在外部使用。



​        抽象类和接口也可以定义内部类

```
interface IChannel { //定义接口
    public void send(IMessage msg); //发送消息
    interface IMessage { //内部接口
        public String getContent();
    }
}

class ChannelImpl implements IChannel {
    public void send(IMessage msg) {
        System.out.println("发送消息：" + msg.getContent());
    }

    class MessageImpl implements IMessage {
        public String getContent() {
            return "www.mldn.cn";
        }
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        IChannel channel = new ChannelImpl();
        channel.send(((ChannelImpl)channel).new MessageImpl());
    }
}
```

​        下面继续观察一个内部的抽象类，内部抽象类可以定义在普通类，抽象类，接口内部。

```
interface IChannel { //定义接口
    public void send(); //发送消息
    abstract class AbstractMessage { //内部接口
        public abstract String getContent();
    }
}

class ChannelImpl implements IChannel {
    public void send() {
        AbstractMessage msg = new MessageImpl();
        System.out.println(msg.getContent());
    }

    class MessageImpl extends AbstractMessage {
        @Override
        public String getContent() {
            return "www.mldn.cn";
        }
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        IChannel channel = new ChannelImpl();
        channel.send();
    }
}
```



​        内部类还有更有意思的结构：如果现在定义了一个接口，那么可以在内部利用类实现该接口，在JDK1.8之后追加了static方法可以不受到实例化对象的控制，现在可以利用磁特性来完成该功能

```
interface IChannel { //定义接口
    public void send(); //发送消息
    class ChannelImpl implements IChannel {
        public void send() {
            System.out.println("www.mldn.cn");
        }
    }

    public static IChannel getInstance() {
        return new ChannelImpl();
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        IChannel channel = IChannel.getInstance();
        channel.send();
    }
}
```

​        内部类是一个非常灵活的结构，只要语法满足了，就可以实现各种需求。

​        日后开发可能会碰到接口提供静态方法，但是却没有相应实现，那就有可能是在内部实现了接口。

# 三、static定义内部类

​        如果说现在在内部上使用了static定义，那么这个内部类就变为了“外部类”，static定义的都是独立于类的结构，所以该类结构就相当于是一个独立的程序类了。需要注意的是，static定义的类和方法只能访问static成员，所以static定义的内部类只能够访问外部类中的static属性和方法

```
class Outer {
    private static final String MSG = "www.mldn.cn";

    static class Inner {
        public void print() {
            System.out.println(Outer.MSG);
        }
    }
}
```

​        这个时候的Inner类是一个独立的类，如果此时想要实例化Inner类对象，只需要根据“外部类.内部类”的结构实例化对象。此时的类名称带有“.”

> 外部类.内部类 内部类对象 = new 外部类.内部类();

```
public class Main {
    public static void main(String[] args) throws Exception {
        Outer.Inner in = new Outer.Inner();
        in.print();
    }
}
```

​         看见“.”的类名称，先确定是内部类；若能够直接进行实例化，则是一个static内部类。

​         static定义内部接口的形式最为常用

```
interface IMessageWarp {    //消息包装
    static interface IMessage {
        public String getContent();
    }

    static interface IChannel {
        public boolean connect();//消息的发送通道
    }

    public static void send(IMessage msg, IChannel channel) {//消息发送
        if (channel.connect()) {
            System.out.println(msg.getContent());
        } else {
            System.out.println("消息通道无法建立，发送失败");
        }
    }
}

class DefaultMessage implements IMessageWarp.IMessage {
    @Override
    public String getContent() {
        return "www.mldn.cn";
    }
}

class NetChannel implements IMessageWarp.IChannel {
    @Override
    public boolean connect() {
        return true;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        IMessageWarp.send(new DefaultMessage(), new NetChannel());
    }
}
```

​        之所以使用static定义内部接口，主要是这些操作是属于一组相关的定义，有了外部接口后可以更加明确地描述出这些接口的主要功能。

# 四、方法中定义内部类

​        内部类可以在任意的结构中进行定义，这就包括了：类中、方法中、代码块中，但是从实际的开发来讲，在方法中定义内部类的形式较多

```
class Outer {
    private String msg = "www.mldn.cn";
    public void fun(long time) {
        class Inner {//内部类
            public void print() {
                System.out.println(Outer.this.msg);
                System.out.println(time);
            }
        }
        new Inner().print();//方法中直接实例化内部类对象
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        new Outer().fun(213123L);
    }
}
```

​        此时在fun()方法内部提供有Inner内部类的定义，并且可以发现内部类可以直接访问外部类的私有属性和方法的参数，但是对于方法中的参数访问是从JDK1.8开始的，在JDK1.8以前内部类要想访问方法中的参数，则参数前必须追加final。

```
class Outer {
    private String msg = "www.mldn.cn";
    public void fun(final long time) {//参数要加final
        final String info = "asfads";//局部变量也要加final
        class Inner {//内部类
            public void print() {
                System.out.println(Outer.this.msg);
                System.out.println(time);
            }
        }
        new Inner().print();//方法中直接实例化内部类对象
    }
}
```

​        之所以取消这种限制，主要是为了其扩展的函数式编程准备的功能。

# 五、匿名内部类

​        匿名内部类是一种简化的内部类的处理形式，其主要是在抽象类和接口的子类上使用的

```
interface IMessage {
    public void send(String str);
}

class MessageImpl implements IMessage {
    @Override
    public void send(String str) {
        System.out.println(str);
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        IMessage msg = new MessageImpl();
        msg.send("www.mldn.cn");
    }
}
```

​         如果MessageImpl子类只使用唯一的一次，那么是否还有必要将其定义为单独的类。这种情况下，定义子类有些多余，可以利用匿名内部类解决  

```
interface IMessage {
    public void send(String str);
}

public class Main {
    public static void main(String[] args) throws Exception {
        IMessage msg = new IMessage() {
            @Override
            public void send(String str) {
                System.out.println(str);
            }
        };
        msg.send("www.mldn.cn");
    }
}
```

​        匿名内部类实际上也会被编译出来，只不过没有名称。

​        有些时候，为了更加方便体现出匿名内部类的使用，往往可以利用静态方法做一个内部的匿名内部类实现