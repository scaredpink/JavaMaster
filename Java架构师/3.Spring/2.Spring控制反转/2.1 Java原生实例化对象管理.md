# 2.1 Java原生实例化对象管理

> 项目模块：origin-java-example

​	Spring的出现一定有其背景原因：原生的Java在语言的设计方面出现了不足。

## 1.原生Java系统的问题分析

### 1.1 原始开发

​	Java面向对象编程是以**类和对象**为基础展开的，而Java的语法是围绕着**类结构代码的可重用设计**展开的。为了更好地表达出不同层次，开发中往往会引入接口与抽象类，所以一个完整的系统开发往往如下图

![image-20250122165957337](assets/image-20250122165957337.png)



​	对于最原始的Java开发的系统，每一个用户请求都会对应一个线程，每一个线程都会导致业务处理相关类的实例化，导致对象数量暴涨，影响程序的执行性能。

![image-20250122170635185](assets/image-20250122170635185.png)

​	造成这种问题的原因就是代码中频繁地使用关键字`new`来实例化对象。`new`调用类的构造方法，随后在堆栈中进行内存分配。但是这造成了两个问题：

1. 正是由于其逻辑的简单，导致了大量创建业务实现类对象。
2. 实例化接口时需要绑定对应的实现子类，这样的话抽象出接口的意义就没有了。

> 抽象出接口的意义是避免耦合，可以简单理解为想让代码的使用范围更广。如果绑定了接口的实现子类，意味着这段代码一定与这个子类耦合了，这段代码就失去了泛用性。

![image-20250122171124264](assets/image-20250122171124264.png)

---

### 1.2 工厂设计模式

​	如果接口在实例化时可以根据输入动态返回实现子类，那么代码的泛用性就会极大的提高。这段代码从针对实现子类的维度变成了针对接口的维度。

​	于是在聪明的前辈们的思考下，**==工厂设计模式==**解决了这个问题。它根据字符串提供的类名动态提供实现子类，极大提高了泛用性。

![image-20250122172749061](assets/image-20250122172749061.png)

----

### 1.3 Bean模式管理

​	现在还有一个问题：对于不同用户提交的VO数据类，每个线程都肯定要有自己的VO对象实例。但是，业务接口的实现类实际上并不需要每个线程都实例化一个新的出来，因为不管是哪个用户，执行的逻辑都是相同的。

​	如果我们能够在系统在启动的初始化阶段，把系统中所有用到的业务实现类都实例化出来，并且使用一个`Map`将其记录下来。之后当系统中代码需要调用某个类时，由工厂将该唯一实例返回给它。这样，就保证了不会出现频繁创建出新的实例，保证了性能。

> 需要区分开VO数据类和业务接口实现类。举个例子，大家都去打印个人信息，每个人的信息肯定都不一样，所以个人信息类一定会有很多个对象，但是打印机只需要一台不就够了吗，所以打印机类完全可以只实例化一次。

![image-20250122173740220](assets/image-20250122173740220.png)





## 2.原生Java开发简单案例

​	创建项目（或模块）: *origin-java-example*

```
origin-java-example
|-src
    |-main
        |-java
            |-自定义包路径
                |-service
                    |-impl
                        |-QQMessageServiceImpl.java
                        |-WechatMessageServiceImpl.java
                    |-IMessageService.java
                |-Main.java
    |-test
	
```

### 1.消息服务接口

​	目标不是写很复杂的接口，因此一切从简，就只是一个打印接收到的信息的接口就行啦

```java
package i.love.wsq.service;

public interface IMessageService {
    public void echo(String message);
}
```



### 2.消息服务实现

​	为了演示多态，我们写两个实现类，QQ消息和微信消息

```java
package i.love.wsq.service.impl;

import i.love.wsq.service.IMessageService;

public class QQMessageServiceImpl implements IMessageService {
    @Override
    public void echo(String message) {
        System.out.println("【QQ服务】" + message);
    }
}
```

```java
package i.love.wsq.service.impl;

import i.love.wsq.service.IMessageService;

public class WechatMessageServiceImpl implements IMessageService {
    @Override
    public void echo(String message) {
        System.out.println("【微信服务】" + message);
    }
}
```



### 3.测试类

​	测试类就可以理解为客户端了，为了简单我们直接把Main当测试类，不单独写测试了

```java
package i.love.wsq;

import i.love.wsq.service.IMessageService;
import i.love.wsq.service.impl.QQMessageServiceImpl;

public class Main {
    public static void main(String[] args) {
        IMessageService messageService = new QQMessageServiceImpl();
        messageService.echo("灵感菇🐧🌹");
    }
}
```

​	现在我们可以开始分析这个测试类了。

​	它使用了关键字new直接实例化了`QQMessageServiceImpl`子类，这就是耦合了子类。





## 3.反射工厂





