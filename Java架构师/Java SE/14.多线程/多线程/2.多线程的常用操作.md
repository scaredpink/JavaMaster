# 多线程的常用操作

*项目：thread-method*

​	通过Thread类实现的各种方法，我们也可以学习到多线程本身是如何使用的。

## 1.创建多线程

​	参照[多线程编程](./1.多线程编程.md)

​	Thread构造方法：

- 无参构造：`Thread()`
- 指定`run()`方法：`Thread(Runnable target)`
- 指定`run()`方法和线程名：`Thread(Runnable target, String name)`
- 指定线程名：`Thread(String name)`



## 2.线程的名字与获取

​	多线程的运行状态是不确定的，为了获取到一些需要使用的线程，就需要依靠线程的名字来进行操作。所以线程的名字是一个至关重要的概念，这样在Thread类中就提供有线程名称：

- 构造方法：`public Thread(Runnable target, String name)`
- 设置名字：`public final void setName(String name)`
- 取得名字：`public final String getName()`



​	对于线程对象的获得是不可能只是依靠一个`this`来完成的，因为线程的状态不可控。但有一点是明确的，所有的线程一定要执行`run()`方法，那么这个时候可以考虑获取当前线程，在`Thread`类里面提供有获取当前线程的方法：

- `public static Thread currentThread()`。



范例：观察线程的命名操作

```java
public class ThreadName {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        new Thread(myRunnable, "线程1号").start();
        new Thread(myRunnable).start();
        new Thread(myRunnable, "线程3号").start();
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

```
线程1号
Thread-0
线程3号
```





​	可以看到如果没有命名的话，Thread也会自动有一个编号，这是Thread类中给的自动命名：

```java
//没有命名构造方法
public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
}

//staitc属性 和 提供命名的方法
private static int threadInitNumber;
private static synchronized int nextThreadNum() {
        return threadInitNumber++;
}
```





## 3.线程休眠

​	如果说现在希望某一个线程可以暂缓执行一次，那么可以使用休眠的处理，在Thread类之中定义的休眠方法如下：

- 休眠：`public static void sleep(long millis) throws InterruptedException`

- 休眠：`public static void sleep(long millis, int nanos) throws InterruptedException`

​        在进行休眠的时候有可能会产生中断异常`InterruptedException`，中断异常属于`Exception`异常，意味着必须处理。

```java
public class ThreadSleep {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i ++ ) {
            new Thread(() -> {
                for (int j = 0; j < 10; j ++) {
                    System.out.println(Thread.currentThread().getName() + "-" + j);
                    try {
                        Thread.sleep(0, 1);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }

            }, "线程" + i).start();
        }
    }
}
```

​	虽然看起来像是若干个程序一起休眠一起唤醒，但是其实不是。实际上休眠也是有前有后的，只不过执行一个打印的时间远小于打印一个符号，所以导致没有乱序出来。



## 4.线程等待

​	一个线程还可以等待另一个线程直到其运行结束。例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行：

```java
// 多线程
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            System.out.println("hello");
        });
        System.out.println("start");
        t.start(); // 启动t线程
        t.join(); // 此处main线程会等待t结束
        System.out.println("end");
    }
}
```

​	当`main`线程对线程对象`t`调用`join()`方法时，主线程将等待变量`t`表示的线程运行结束，即`join`就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是`main`线程先打印`start`，`t`线程再打印`hello`，`main`线程最后再打印`end`。

​	如果`t`线程已经结束，对实例`t`调用`join()`会立刻返回。此外，`join(long)`的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。





## 5.线程中断

​	线程可以被打断，就像我们可以下载到一半停止下载一样。Thread类中提供了中断执行的方法：

- 判断线程是否被中断：`public boolean isInterrupted()`
- 中断线程执行：`public void interrupt()`



​	需要注意的是中断A线程的行为一定是另一个线程B发起的。线程被打断了并不是直接让线程停止运行，而是向线程发送了中断的请求。只有线程中对于中断请求有响应时，中断才能发挥作用。我们可以用主线程打断子线程的运行：

```java
public class ThreadInterrupt {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new MyThread("曼波线程");
        t.start();
        Thread.sleep(10);
        t.interrupt();
        System.out.println("曼波被打断了");
    }
}

class MyThread extends Thread {
    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        int n = 0;
        while (! isInterrupted()) {
            n ++;
            System.out.printf("第%d次哦耶%n", n);
        }
    }
}
```



















